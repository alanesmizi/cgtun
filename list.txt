./Errors.txt:./cableguard/src/noise/session.rs:            return Err(WireGuardError::InvalidCounter);
./Errors.txt:./cableguard/src/noise/session.rs:            Err(WireGuardError::DuplicateCounter)
./Errors.txt:./cableguard/src/noise/session.rs:            return Err(WireGuardError::InvalidCounter);
./Errors.txt:./cableguard/src/noise/session.rs:                return Err(WireGuardError::InvalidCounter);
./Errors.txt:./cableguard/src/noise/session.rs:            return Err(WireGuardError::WrongSessionIndex);
./Errors.txt:./cableguard/src/noise/session.rs:                .map_err(|_| WireGuardError::InvalidAeadTag)?
./Errors.txt:./cableguard/src/noise/session.rs:                Err(WireGuardError::InvalidCounter)
./Errors.txt:./cableguard/src/noise/session.rs:            Err(WireGuardError::DuplicateCounter)
./Errors.txt:./cableguard/src/noise/rate_limiter.rs:            return Err(WireGuardError::DestinationBufferTooSmall);
./Errors.txt:./cableguard/src/noise/rate_limiter.rs:            .map_err(|_| WireGuardError::DestinationBufferTooSmall)?;
./Errors.txt:./cableguard/src/noise/rate_limiter.rs:                .map_err(|_| TunnResult::Err(WireGuardError::InvalidMac))?;
./Errors.txt:./cableguard/src/noise/rate_limiter.rs:                    None => return Err(TunnResult::Err(WireGuardError::UnderLoad)),
./Errors.txt:./cableguard/src/noise/handshake.rs:        .map_err(|_| WireGuardError::InvalidAeadTag)?;
./Errors.txt:./cableguard/src/noise/handshake.rs:            return Err(WireGuardError::InvalidTai64nTimestamp);
./Errors.txt:./cableguard/src/noise/handshake.rs:        //    return Err(WireGuardError::InvalidTai64nTimestamp);
./Errors.txt:./cableguard/src/noise/handshake.rs:        //   return Err(WireGuardError::InvalidTai64nTimestamp);
./Errors.txt:./cableguard/src/noise/handshake.rs:        .map_err(|_| WireGuardError::WrongKey)?;
./Errors.txt:./cableguard/src/noise/handshake.rs:            return Err(WireGuardError::WrongTai64nTimestamp);
./Errors.txt:./cableguard/src/noise/handshake.rs:            _ => return Err(WireGuardError::UnexpectedPacket),
./Errors.txt:./cableguard/src/noise/handshake.rs:                return Err(WireGuardError::UnexpectedPacket);
./Errors.txt:./cableguard/src/noise/handshake.rs:            return Err(WireGuardError::WrongSessionIndex);
./Errors.txt:./cableguard/src/noise/handshake.rs:            .map_err(|_| WireGuardError::InvalidAeadTag)?;
./Errors.txt:./cableguard/src/noise/handshake.rs:            .map_err(|_| WireGuardError::InvalidPacket)?;
./Errors.txt:./cableguard/src/noise/handshake.rs:            return Err(WireGuardError::DestinationBufferTooSmall);
./Errors.txt:./cableguard/src/noise/handshake.rs:                tracing::debug!("Error: [u8:128] to String conversion error: {:?}", error);
./Errors.txt:./cableguard/src/noise/handshake.rs:            return Err(WireGuardError::DestinationBufferTooSmall);
./Errors.txt:./cableguard/src/noise/timers.rs:                return TunnResult::Err(WireGuardError::ConnectionExpired);
./Errors.txt:./cableguard/src/noise/timers.rs:                return TunnResult::Err(WireGuardError::ConnectionExpired);
./Errors.txt:./cableguard/src/noise/timers.rs:                    return TunnResult::Err(WireGuardError::ConnectionExpired);
./Errors.txt:./cableguard/src/noise/mod.rs:            return Err(WireGuardError::InvalidPacket);
./Errors.txt:./cableguard/src/noise/mod.rs:            _ => return Err(WireGuardError::InvalidPacket),
./Errors.txt:./cableguard/src/noise/mod.rs:            .map_err(|_| "Error: Invalid parameters")?,
./Errors.txt:./cableguard/src/noise/mod.rs:                            tracing::debug!("Error: PeerEd25519SignatureVerificationFailure");
./Errors.txt:./cableguard/src/noise/mod.rs:                            return Err(WireGuardError::PeerEd25519SignatureVerificationFailure);
./Errors.txt:./cableguard/src/noise/mod.rs:                tracing::debug!("Error: There is no server RODT associated with the account: {}", err);
./Errors.txt:./cableguard/src/noise/mod.rs:                    tracing::debug!("Error: PeerEd25519SignatureVerificationFailure");
./Errors.txt:./cableguard/src/noise/mod.rs:                    return Err(WireGuardError::PeerEd25519SignatureVerificationFailure);
./Errors.txt:./cableguard/src/noise/mod.rs:                tracing::trace!(message = "Error: No current session available", sender_session_index = receiving_index);
./Errors.txt:./cableguard/src/noise/mod.rs:                WireGuardError::NoCurrentSession
./Errors.txt:./cableguard/src/noise/mod.rs:            _ => return TunnResult::Err(WireGuardError::InvalidPacket),
./Errors.txt:./cableguard/src/noise/mod.rs:            return TunnResult::Err(WireGuardError::InvalidPacket);
./Errors.txt:./cableguard/src/noise/mod.rs:.expect("Error: Failed to convert byte slice to string")
./Errors.txt:./cableguard/src/noise/mod.rs:            .expect("Error: Failed to decode hex string");
./Errors.txt:./cableguard/src/noise/mod.rs:            .expect("Error: Invalid byte array length");
./Errors.txt:./cableguard/src/noise/mod.rs:                                .expect("Error: Failed to decode hex string");
./Errors.txt:./cableguard/src/noise/mod.rs:                                    .expect("Error: Invalid byte array length");
./Errors.txt:./cableguard/src/noise/mod.rs:                                let serviceprovider_bytes_signature = decode(&fetched_rodt.metadata.serviceprovidersignature).expect("Error: Base64 decoding error");
./Errors.txt:./cableguard/src/noise/mod.rs:                                    .expect("Error: Invalid public key length");
./Errors.txt:./cableguard/src/noise/mod.rs:                                                    tracing::debug!("Error: ServiceProviderEd25519SignatureVerificationFailure");
./Errors.txt:./cableguard/src/noise/mod.rs:                                                    // Err(WireGuardError::ServiceProviderEd25519SignatureVerificationFailure)
./Errors.txt:./cableguard/src/noise/mod.rs:                                            tracing::debug!("Error: ServiceProviderEd25519SignatureParsingFailure");
./Errors.txt:./cableguard/src/noise/mod.rs:                                            Err(WireGuardError::ServiceProviderEd25519SignatureParsingFailure)
./Errors.txt:./cableguard/src/noise/mod.rs:                                    tracing::debug!("Error: ServiceProviderEd25519PublicKeyParsingFailure");
./Errors.txt:./cableguard/src/noise/mod.rs:                                    Err(WireGuardError::ServiceProviderEd25519PublicKeyParsingFailure)
./Errors.txt:./cableguard/src/noise/mod.rs:                                tracing::debug!("Error: ServiceProviderEd25519SignatureFetchingFailure");
./Errors.txt:./cableguard/src/noise/mod.rs:                                return Err(WireGuardError::ServiceProviderEd25519SignatureFetchingFailure);
./Errors.txt:./cableguard/src/noise/mod.rs:                        tracing::debug!("Error: PeerEd25519SignatureVerificationFailure");
./Errors.txt:./cableguard/src/noise/mod.rs:                        return Err(WireGuardError::PeerEd25519SignatureVerificationFailure)
./Errors.txt:./cableguard/src/noise/mod.rs:                    tracing::debug!("Error: PeerEd25519PublicKeyParsingFailure");
./Errors.txt:./cableguard/src/noise/mod.rs:                    return Err(WireGuardError::PeerEd25519PublicKeyParsingFailure)
./Errors.txt:./cableguard/src/noise/mod.rs:                tracing::debug!("Error: PeerEd25519SignatureParsingFailure");
./Errors.txt:./cableguard/src/noise/mod.rs:                return Err(WireGuardError::PeerEd25519SignatureParsingFailure);
./Errors.txt:./cableguard/src/noise/mod.rs:        tracing::debug!("Error: There is no server RODT associated with the account: {}", err);
./Errors.txt:./cableguard/src/ffi/mod.rs:            Err(Error::new(
./Errors.txt:./cableguard/src/ffi/mod.rs:                "Error: Failed to create CString from buffer.",
./Errors.txt:./cableguard/src/device/integration_tests/mod.rs:                    tracing::debug!("Error: failed to connect: {:?}", err);
./Errors.txt:./cableguard/src/device/tun_linux.rs:            -1 => return Err(Error::Socket(io::Error::last_os_error())),
./Errors.txt:./cableguard/src/device/tun_linux.rs:            return Err(Error::InvalidTunnelName);
./Errors.txt:./cableguard/src/device/tun_linux.rs:            return Err(Error::IOCtl(io::Error::last_os_error()));
./Errors.txt:./cableguard/src/device/tun_linux.rs:            -1 => Err(Error::FCntl(io::Error::last_os_error())),
./Errors.txt:./cableguard/src/device/tun_linux.rs:                -1 => Err(Error::FCntl(io::Error::last_os_error())),
./Errors.txt:./cableguard/src/device/tun_linux.rs:            -1 => return Err(Error::Socket(io::Error::last_os_error())),
./Errors.txt:./cableguard/src/device/tun_linux.rs:            return Err(Error::IOCtl(io::Error::last_os_error()));
./Errors.txt:./cableguard/src/device/tun_linux.rs:            -1 => Err(Error::IfaceRead(io::Error::last_os_error())),
./Errors.txt:./cableguard/src/device/peer.rs:            return Err("Error: Invalid IP format".to_owned());
./Errors.txt:./cableguard/src/device/peer.rs:            _ => Err("Error: Invalid IP format".to_owned()),
./Errors.txt:./cableguard/src/device/peer.rs:            return Err(Error::Connect("Connected".to_owned()));
./Errors.txt:./cableguard/src/device/tun_darwin.rs:        return Err(Error::InvalidTunnelName);
./Errors.txt:./cableguard/src/device/tun_darwin.rs:                .map_err(|_| Error::InvalidTunnelName)
./Errors.txt:./cableguard/src/device/tun_darwin.rs:            -1 => return Err(Error::Socket(io::Error::last_os_error())),
./Errors.txt:./cableguard/src/device/tun_darwin.rs:            return Err(Error::IOCtl(io::Error::last_os_error()));
./Errors.txt:./cableguard/src/device/tun_darwin.rs:            let mut err_string = io::Error::last_os_error().to_string();
./Errors.txt:./cableguard/src/device/tun_darwin.rs:            return Err(Error::Connect(err_string));
./Errors.txt:./cableguard/src/device/tun_darwin.rs:            -1 => Err(Error::FCntl(io::Error::last_os_error())),
./Errors.txt:./cableguard/src/device/tun_darwin.rs:                -1 => Err(Error::FCntl(io::Error::last_os_error())),
./Errors.txt:./cableguard/src/device/tun_darwin.rs:            return Err(Error::GetSockOpt(io::Error::last_os_error()));
./Errors.txt:./cableguard/src/device/tun_darwin.rs:            -1 => return Err(Error::Socket(io::Error::last_os_error())),
./Errors.txt:./cableguard/src/device/tun_darwin.rs:            return Err(Error::IOCtl(io::Error::last_os_error()));
./Errors.txt:./cableguard/src/device/tun_darwin.rs:            -1 => Err(Error::IfaceRead(io::Error::last_os_error())),
./Errors.txt:./cableguard/src/device/kqueue.rs:            -1 => return Err(Error::EventQueue(io::Error::last_os_error())),
./Errors.txt:./cableguard/src/device/kqueue.rs:            return WaitResult::Error(io::Error::last_os_error().to_string());
./Errors.txt:./cableguard/src/device/kqueue.rs:            return Err(Error::EventQueue(io::Error::last_os_error()));
./Errors.txt:./cableguard/src/device/drop_privileges.rs:            Err(e) => Err(Error::DropPrivileges(format!(
./Errors.txt:./cableguard/src/device/drop_privileges.rs:            Ok(None) => Err(Error::DropPrivileges("Failed to find user".to_owned())),
./Errors.txt:./cableguard/src/device/drop_privileges.rs:        Err(e) => Err(Error::DropPrivileges(format!(
./Errors.txt:./cableguard/src/device/drop_privileges.rs:            return Err(Error::DropPrivileges("NULL from getlogin".to_owned()));
./Errors.txt:./cableguard/src/device/drop_privileges.rs:            return Err(Error::DropPrivileges("NULL from getpwnam".to_owned()));
./Errors.txt:./cableguard/src/device/drop_privileges.rs:        return Err(Error::DropPrivileges(
./Errors.txt:./cableguard/src/device/drop_privileges.rs:            io::Error::last_os_error().to_string(),
./Errors.txt:./cableguard/src/device/drop_privileges.rs:        return Err(Error::DropPrivileges(
./Errors.txt:./cableguard/src/device/drop_privileges.rs:            io::Error::last_os_error().to_string(),
./Errors.txt:./cableguard/src/device/drop_privileges.rs:        Err(Error::DropPrivileges(
./Errors.txt:./cableguard/src/device/api.rs:            tracing::debug!("Error: can't handle RODT struct {:?}",result_string);
./Errors.txt:./cableguard/src/device/api.rs:            tracing::debug!("Error: can't handle RODT iter  {}",result_string);
./Errors.txt:./cableguard/src/device/api.rs:        return Err("Error: No Rodt instance found".into());
./Errors.txt:./cableguard/src/device/api.rs:    let result_array = parsed_json["result"]["result"].as_array().ok_or("Error: Result is not an array")?;
./Errors.txt:./cableguard/src/device/api.rs:        tracing::debug!("Error: {}","The account does not exist in the blockchain, it needs to be funded with at least 0.01 NEAR");
./Errors.txt:./cableguard/src/device/api.rs:        return Err("Error: The account does not exist in the blockchain".into());
./Errors.txt:./cableguard/src/device/api.rs:        let api_listener = UnixListener::bind(&path).map_err(Error::ApiSocket)?; // Bind a new socket to the path
./Errors.txt:./cableguard/src/device/api.rs:                                        tracing::debug!("Error: Could not create DNS resolver");
./Errors.txt:./cableguard/src/device/api.rs:                                        tracing::debug!("Error: IP lookup for subdomain failed");
./Errors.txt:./cableguard/src/device/api.rs:                                let ipaddress = ipresponse.iter().next().expect("Error: No IP address found for subdomain");
./Errors.txt:./cableguard/src/device/api.rs:                                cfgresponse.iter().next().expect("Error: No VPN Server Public Key found!");
./Errors.txt:./cableguard/src/device/api.rs:                                            println!("Error: IP address does not match");
./Errors.txt:./cableguard/src/device/api.rs:                                        println!("Error: Error parsing IP address: {:?}", e);
./Errors.txt:./cableguard/src/device/epoll.rs:            -1 => return Err(Error::EventQueue(io::Error::last_os_error())),
./Errors.txt:./cableguard/src/device/epoll.rs:                -1 => return Err(Error::Timer(io::Error::last_os_error())),
./Errors.txt:./cableguard/src/device/epoll.rs:            return Err(Error::Timer(io::Error::last_os_error()));
./Errors.txt:./cableguard/src/device/epoll.rs:            -1 => return Err(Error::EventQueue(io::Error::last_os_error())),
./Errors.txt:./cableguard/src/device/epoll.rs:            -1 => return Err(Error::EventQueue(io::Error::last_os_error())),
./Errors.txt:./cableguard/src/device/epoll.rs:            -1 => return WaitResult::Error(io::Error::last_os_error().to_string()),
./Errors.txt:./cableguard/src/device/epoll.rs:            return Err(Error::EventQueue(io::Error::last_os_error()));
./Errors.txt:./cableguard/src/device/epoll.rs:            return Err(io::Error::last_os_error().to_string());
./Errors.txt:./cableguard/src/device/epoll.rs:            return Err(io::Error::last_os_error().to_string());
./Errors.txt:./cableguard/src/device/mod.rs:    #[error("Error: Invalid tunnel name")]
./Errors.txt:./cableguard/src/device/mod.rs:                    WaitResult::Error(e) => tracing::debug!(message = "Error: Poll error", error = ?e),
./Errors.txt:./cableguard/src/device/mod.rs:        .expect("Error: Self private key must be set before adding peers");
./Errors.txt:./cableguard/src/device/mod.rs:        .expect("Error: Invalid private key bytes");
./Errors.txt:./cableguard/src/device/mod.rs:            .expect("Error: Failed to execute command");
./Errors.txt:./cableguard/src/device/mod.rs:            tracing::debug!("Error: Ip addr add command failed to execute {}", stderr);
./Errors.txt:./cableguard/src/device/mod.rs:                .expect("Error: Failed to execute postup command");
./Errors.txt:./cableguard/src/device/mod.rs:                tracing::debug!("Error: postup command failed to execute {}", stderr);
./Errors.txt:./cableguard/src/device/mod.rs:                    let ipaddress = ipresponse.iter().next().expect("Error: No IP address found for subdomain");
./Errors.txt:./cableguard/src/device/mod.rs:                    cfgresponse.iter().next().expect("Error: No VPN Server Public Key found!");
./Errors.txt:./cableguard/src/device/mod.rs:                Err(_) => {tracing::debug!("Error: There is no RODT associated with the account");  }
./Errors.txt:./cableguard/src/device/mod.rs:                        TunnResult::Err(WireGuardError::ConnectionExpired) => {
./Errors.txt:./cableguard/src/device/mod.rs:                        TunnResult::Err(e) => tracing::debug!(message = "Error: Timer error", error = ?e),
./Errors.txt:./cableguard/src/device/mod.rs:                    let (own_bytes_private_key, own_bytes_public_key) = device.key_pair.as_ref().expect("Error: Key not set").clone();
./Errors.txt:./cableguard/src/device/mod.rs:                                                        .expect("Error: Self private key must be set before adding peers")
./Errors.txt:./cableguard/src/device/mod.rs:                                                        .expect("Error: Invalid private key bytes");
./Errors.txt:./cableguard/src/device/mod.rs:                                                    let allowed_ip: AllowedIP = allowed_ip_str.parse().expect("Error: Invalid Allowed IP");
./Errors.txt:./cableguard/src/device/mod.rs:                        Err(Error::IfaceRead(e)) => {
./Errors.txt:./cableguard/src/device/mod.rs:                            tracing::debug!("Error: Fatal read error on tun interface: {:?}", e);
./Errors.txt:./cableguard/src/device/mod.rs:                            tracing::debug!("Error: Unexpected error on tun interface: {:?}", e);
./Errors.txt:./cableguard/src/device/mod.rs:                            tracing::debug!(message = "Error: Encapsulate error", error = ?e)
./Errors.txt:./cableguard/src/device/mod.rs:                                tracing::debug!("Error: No endpoint");
./Errors.txt:./cableguard/src/device/mod.rs:        let allowed_ip: AllowedIP = allowed_ip_str.parse().expect("Error: Invalid own AllowedIP");
./Errors.txt:./cableguard/src/device/mod.rs:        // let ipv6_allowed_ip: AllowedIP = ipv6_allowed_ip_str.parse().expect("Error: Invalid IPv6 AllowedIP");
./Errors.txt:./cableguard/src/device/mod.rs:    // let ed25519_pub_bytes = hex::decode(key).expect("Error: Invalid hexadecimal string");
./Errors.txt:./cableguard/src/device/mod.rs:    let ed25519_pub_array: [u8; 32] = ed25519_pub_bytes.as_slice().try_into().expect("Error: Invalid length");
./Errors.txt:./.git/hooks/pre-commit.sample:Error: Attempt to add a non-ASCII file name.
./Errors.txt:./walletsh/cgtunup.sh:  echo "Error: Could not determine the WireGuard interface name."
./Errors.txt:./cableguard-cli/src/main.rs:            tracing::debug!("Error: Failed to open the file with the accountId: {}", err);
./Errors.txt:./cableguard-cli/src/main.rs:        tracing::debug!("Error: Failed to read the file with the accountId: {}", err);
./Errors.txt:./cableguard-cli/src/main.rs:            tracing::debug!("Error: Failed to parse JSON of the file with the accountId: {}", err);
./Errors.txt:./cableguard-cli/src/main.rs:    let account_id = json["account_id"].as_str().expect("Error: Invalid account_id value");
./Errors.txt:./cableguard-cli/src/main.rs:    let own_static_base58_private_ed25519_key = json["private_key"].as_str().expect("Error: Invalid private_key value");   
./Errors.txt:./cableguard-cli/src/main.rs:            tracing::debug!("Error: Account has no NEAR balance): {}", err);
./Errors.txt:./cableguard-cli/src/main.rs:            tracing::debug!("Error: There is no RODT associated with the account: {}", err);
./Errors.txt:./cableguard-cli/src/main.rs:        .expect("Error: Failed to decode the private key from Base58");
./Errors.txt:./cableguard-cli/src/main.rs:                Err(io::Error::new(
./Errors.txt:./cableguard-cli/src/main.rs:        .unwrap_or_else(|err| panic!("Error: Could not open log file {}: {}", log, err));
./Errors.txt:./cableguard-cli/src/main.rs:                    tracing::debug!("Error: CableGuard failed to start. Check if the capabilities are set and you are running with enough privileges.");
./Errors.txt:./cableguard-cli/src/main.rs:            tracing::debug!(message = "Error: Failed to initialize tunnel. Check if you are running with sudo", error=?e);
./Errors.txt:./cableguard-cli/src/main.rs:            tracing::debug!(message = "Error: Failed to drop privileges", error = ?e);
./Errors.txt:./cableguard-cli/src/main.rs:    let bytes = Vec::from_hex(&hex_string).expect("Error: Invalid Hex string");
./cableguard/src/noise/session.rs:            return Err(WireGuardError::InvalidCounter);
./cableguard/src/noise/session.rs:            Err(WireGuardError::DuplicateCounter)
./cableguard/src/noise/session.rs:            return Err(WireGuardError::InvalidCounter);
./cableguard/src/noise/session.rs:                return Err(WireGuardError::InvalidCounter);
./cableguard/src/noise/session.rs:            return Err(WireGuardError::WrongSessionIndex);
./cableguard/src/noise/session.rs:                .map_err(|_| WireGuardError::InvalidAeadTag)?
./cableguard/src/noise/session.rs:                Err(WireGuardError::InvalidCounter)
./cableguard/src/noise/session.rs:            Err(WireGuardError::DuplicateCounter)
./cableguard/src/noise/rate_limiter.rs:            return Err(WireGuardError::DestinationBufferTooSmall);
./cableguard/src/noise/rate_limiter.rs:            .map_err(|_| WireGuardError::DestinationBufferTooSmall)?;
./cableguard/src/noise/rate_limiter.rs:                .map_err(|_| TunnResult::Err(WireGuardError::InvalidMac))?;
./cableguard/src/noise/rate_limiter.rs:                    None => return Err(TunnResult::Err(WireGuardError::UnderLoad)),
./cableguard/src/noise/handshake.rs:        .map_err(|_| WireGuardError::InvalidAeadTag)?;
./cableguard/src/noise/handshake.rs:            return Err(WireGuardError::InvalidTai64nTimestamp);
./cableguard/src/noise/handshake.rs:        //    return Err(WireGuardError::InvalidTai64nTimestamp);
./cableguard/src/noise/handshake.rs:        //   return Err(WireGuardError::InvalidTai64nTimestamp);
./cableguard/src/noise/handshake.rs:        .map_err(|_| WireGuardError::WrongKey)?;
./cableguard/src/noise/handshake.rs:            return Err(WireGuardError::WrongTai64nTimestamp);
./cableguard/src/noise/handshake.rs:            _ => return Err(WireGuardError::UnexpectedPacket),
./cableguard/src/noise/handshake.rs:                return Err(WireGuardError::UnexpectedPacket);
./cableguard/src/noise/handshake.rs:            return Err(WireGuardError::WrongSessionIndex);
./cableguard/src/noise/handshake.rs:            .map_err(|_| WireGuardError::InvalidAeadTag)?;
./cableguard/src/noise/handshake.rs:            .map_err(|_| WireGuardError::InvalidPacket)?;
./cableguard/src/noise/handshake.rs:            return Err(WireGuardError::DestinationBufferTooSmall);
./cableguard/src/noise/handshake.rs:                tracing::debug!("Error: [u8:128] to String conversion error: {:?}", error);
./cableguard/src/noise/handshake.rs:            return Err(WireGuardError::DestinationBufferTooSmall);
./cableguard/src/noise/timers.rs:                return TunnResult::Err(WireGuardError::ConnectionExpired);
./cableguard/src/noise/timers.rs:                return TunnResult::Err(WireGuardError::ConnectionExpired);
./cableguard/src/noise/timers.rs:                    return TunnResult::Err(WireGuardError::ConnectionExpired);
./cableguard/src/noise/mod.rs:            return Err(WireGuardError::InvalidPacket);
./cableguard/src/noise/mod.rs:            _ => return Err(WireGuardError::InvalidPacket),
./cableguard/src/noise/mod.rs:            .map_err(|_| "Error: Invalid parameters")?,
./cableguard/src/noise/mod.rs:                            tracing::debug!("Error: PeerEd25519SignatureVerificationFailure");
./cableguard/src/noise/mod.rs:                            return Err(WireGuardError::PeerEd25519SignatureVerificationFailure);
./cableguard/src/noise/mod.rs:                tracing::debug!("Error: There is no server RODT associated with the account: {}", err);
./cableguard/src/noise/mod.rs:                    tracing::debug!("Error: PeerEd25519SignatureVerificationFailure");
./cableguard/src/noise/mod.rs:                    return Err(WireGuardError::PeerEd25519SignatureVerificationFailure);
./cableguard/src/noise/mod.rs:                tracing::trace!(message = "Error: No current session available", sender_session_index = receiving_index);
./cableguard/src/noise/mod.rs:                WireGuardError::NoCurrentSession
./cableguard/src/noise/mod.rs:            _ => return TunnResult::Err(WireGuardError::InvalidPacket),
./cableguard/src/noise/mod.rs:            return TunnResult::Err(WireGuardError::InvalidPacket);
./cableguard/src/noise/mod.rs:.expect("Error: Failed to convert byte slice to string")
./cableguard/src/noise/mod.rs:            .expect("Error: Failed to decode hex string");
./cableguard/src/noise/mod.rs:            .expect("Error: Invalid byte array length");
./cableguard/src/noise/mod.rs:                                .expect("Error: Failed to decode hex string");
./cableguard/src/noise/mod.rs:                                    .expect("Error: Invalid byte array length");
./cableguard/src/noise/mod.rs:                                let serviceprovider_bytes_signature = decode(&fetched_rodt.metadata.serviceprovidersignature).expect("Error: Base64 decoding error");
./cableguard/src/noise/mod.rs:                                    .expect("Error: Invalid public key length");
./cableguard/src/noise/mod.rs:                                                    tracing::debug!("Error: ServiceProviderEd25519SignatureVerificationFailure");
./cableguard/src/noise/mod.rs:                                                    // Err(WireGuardError::ServiceProviderEd25519SignatureVerificationFailure)
./cableguard/src/noise/mod.rs:                                            tracing::debug!("Error: ServiceProviderEd25519SignatureParsingFailure");
./cableguard/src/noise/mod.rs:                                            Err(WireGuardError::ServiceProviderEd25519SignatureParsingFailure)
./cableguard/src/noise/mod.rs:                                    tracing::debug!("Error: ServiceProviderEd25519PublicKeyParsingFailure");
./cableguard/src/noise/mod.rs:                                    Err(WireGuardError::ServiceProviderEd25519PublicKeyParsingFailure)
./cableguard/src/noise/mod.rs:                                tracing::debug!("Error: ServiceProviderEd25519SignatureFetchingFailure");
./cableguard/src/noise/mod.rs:                                return Err(WireGuardError::ServiceProviderEd25519SignatureFetchingFailure);
./cableguard/src/noise/mod.rs:                        tracing::debug!("Error: PeerEd25519SignatureVerificationFailure");
./cableguard/src/noise/mod.rs:                        return Err(WireGuardError::PeerEd25519SignatureVerificationFailure)
./cableguard/src/noise/mod.rs:                    tracing::debug!("Error: PeerEd25519PublicKeyParsingFailure");
./cableguard/src/noise/mod.rs:                    return Err(WireGuardError::PeerEd25519PublicKeyParsingFailure)
./cableguard/src/noise/mod.rs:                tracing::debug!("Error: PeerEd25519SignatureParsingFailure");
./cableguard/src/noise/mod.rs:                return Err(WireGuardError::PeerEd25519SignatureParsingFailure);
./cableguard/src/noise/mod.rs:        tracing::debug!("Error: There is no server RODT associated with the account: {}", err);
./cableguard/src/ffi/mod.rs:            Err(Error::new(
./cableguard/src/ffi/mod.rs:                "Error: Failed to create CString from buffer.",
./cableguard/src/device/integration_tests/mod.rs:                    tracing::debug!("Error: failed to connect: {:?}", err);
./cableguard/src/device/tun_linux.rs:            -1 => return Err(Error::Socket(io::Error::last_os_error())),
./cableguard/src/device/tun_linux.rs:            return Err(Error::InvalidTunnelName);
./cableguard/src/device/tun_linux.rs:            return Err(Error::IOCtl(io::Error::last_os_error()));
./cableguard/src/device/tun_linux.rs:            -1 => Err(Error::FCntl(io::Error::last_os_error())),
./cableguard/src/device/tun_linux.rs:                -1 => Err(Error::FCntl(io::Error::last_os_error())),
./cableguard/src/device/tun_linux.rs:            -1 => return Err(Error::Socket(io::Error::last_os_error())),
./cableguard/src/device/tun_linux.rs:            return Err(Error::IOCtl(io::Error::last_os_error()));
./cableguard/src/device/tun_linux.rs:            -1 => Err(Error::IfaceRead(io::Error::last_os_error())),
./cableguard/src/device/peer.rs:            return Err("Error: Invalid IP format".to_owned());
./cableguard/src/device/peer.rs:            _ => Err("Error: Invalid IP format".to_owned()),
./cableguard/src/device/peer.rs:            return Err(Error::Connect("Connected".to_owned()));
./cableguard/src/device/tun_darwin.rs:        return Err(Error::InvalidTunnelName);
./cableguard/src/device/tun_darwin.rs:                .map_err(|_| Error::InvalidTunnelName)
./cableguard/src/device/tun_darwin.rs:            -1 => return Err(Error::Socket(io::Error::last_os_error())),
./cableguard/src/device/tun_darwin.rs:            return Err(Error::IOCtl(io::Error::last_os_error()));
./cableguard/src/device/tun_darwin.rs:            let mut err_string = io::Error::last_os_error().to_string();
./cableguard/src/device/tun_darwin.rs:            return Err(Error::Connect(err_string));
./cableguard/src/device/tun_darwin.rs:            -1 => Err(Error::FCntl(io::Error::last_os_error())),
./cableguard/src/device/tun_darwin.rs:                -1 => Err(Error::FCntl(io::Error::last_os_error())),
./cableguard/src/device/tun_darwin.rs:            return Err(Error::GetSockOpt(io::Error::last_os_error()));
./cableguard/src/device/tun_darwin.rs:            -1 => return Err(Error::Socket(io::Error::last_os_error())),
./cableguard/src/device/tun_darwin.rs:            return Err(Error::IOCtl(io::Error::last_os_error()));
./cableguard/src/device/tun_darwin.rs:            -1 => Err(Error::IfaceRead(io::Error::last_os_error())),
./cableguard/src/device/kqueue.rs:            -1 => return Err(Error::EventQueue(io::Error::last_os_error())),
./cableguard/src/device/kqueue.rs:            return WaitResult::Error(io::Error::last_os_error().to_string());
./cableguard/src/device/kqueue.rs:            return Err(Error::EventQueue(io::Error::last_os_error()));
./cableguard/src/device/drop_privileges.rs:            Err(e) => Err(Error::DropPrivileges(format!(
./cableguard/src/device/drop_privileges.rs:            Ok(None) => Err(Error::DropPrivileges("Failed to find user".to_owned())),
./cableguard/src/device/drop_privileges.rs:        Err(e) => Err(Error::DropPrivileges(format!(
./cableguard/src/device/drop_privileges.rs:            return Err(Error::DropPrivileges("NULL from getlogin".to_owned()));
./cableguard/src/device/drop_privileges.rs:            return Err(Error::DropPrivileges("NULL from getpwnam".to_owned()));
./cableguard/src/device/drop_privileges.rs:        return Err(Error::DropPrivileges(
./cableguard/src/device/drop_privileges.rs:            io::Error::last_os_error().to_string(),
./cableguard/src/device/drop_privileges.rs:        return Err(Error::DropPrivileges(
./cableguard/src/device/drop_privileges.rs:            io::Error::last_os_error().to_string(),
./cableguard/src/device/drop_privileges.rs:        Err(Error::DropPrivileges(
./cableguard/src/device/api.rs:            tracing::debug!("Error: can't handle RODT struct {:?}",result_string);
./cableguard/src/device/api.rs:            tracing::debug!("Error: can't handle RODT iter  {}",result_string);
./cableguard/src/device/api.rs:        return Err("Error: No Rodt instance found".into());
./cableguard/src/device/api.rs:    let result_array = parsed_json["result"]["result"].as_array().ok_or("Error: Result is not an array")?;
./cableguard/src/device/api.rs:        tracing::debug!("Error: {}","The account does not exist in the blockchain, it needs to be funded with at least 0.01 NEAR");
./cableguard/src/device/api.rs:        return Err("Error: The account does not exist in the blockchain".into());
./cableguard/src/device/api.rs:        let api_listener = UnixListener::bind(&path).map_err(Error::ApiSocket)?; // Bind a new socket to the path
./cableguard/src/device/api.rs:                                        tracing::debug!("Error: Could not create DNS resolver");
./cableguard/src/device/api.rs:                                        tracing::debug!("Error: IP lookup for subdomain failed");
./cableguard/src/device/api.rs:                                let ipaddress = ipresponse.iter().next().expect("Error: No IP address found for subdomain");
./cableguard/src/device/api.rs:                                cfgresponse.iter().next().expect("Error: No VPN Server Public Key found!");
./cableguard/src/device/api.rs:                                            println!("Error: IP address does not match");
./cableguard/src/device/api.rs:                                        println!("Error: Error parsing IP address: {:?}", e);
./cableguard/src/device/epoll.rs:            -1 => return Err(Error::EventQueue(io::Error::last_os_error())),
./cableguard/src/device/epoll.rs:                -1 => return Err(Error::Timer(io::Error::last_os_error())),
./cableguard/src/device/epoll.rs:            return Err(Error::Timer(io::Error::last_os_error()));
./cableguard/src/device/epoll.rs:            -1 => return Err(Error::EventQueue(io::Error::last_os_error())),
./cableguard/src/device/epoll.rs:            -1 => return Err(Error::EventQueue(io::Error::last_os_error())),
./cableguard/src/device/epoll.rs:            -1 => return WaitResult::Error(io::Error::last_os_error().to_string()),
./cableguard/src/device/epoll.rs:            return Err(Error::EventQueue(io::Error::last_os_error()));
./cableguard/src/device/epoll.rs:            return Err(io::Error::last_os_error().to_string());
./cableguard/src/device/epoll.rs:            return Err(io::Error::last_os_error().to_string());
./cableguard/src/device/mod.rs:    #[error("Error: Invalid tunnel name")]
./cableguard/src/device/mod.rs:                    WaitResult::Error(e) => tracing::debug!(message = "Error: Poll error", error = ?e),
./cableguard/src/device/mod.rs:        .expect("Error: Self private key must be set before adding peers");
./cableguard/src/device/mod.rs:        .expect("Error: Invalid private key bytes");
./cableguard/src/device/mod.rs:            .expect("Error: Failed to execute command");
./cableguard/src/device/mod.rs:            tracing::debug!("Error: Ip addr add command failed to execute {}", stderr);
./cableguard/src/device/mod.rs:                .expect("Error: Failed to execute postup command");
./cableguard/src/device/mod.rs:                tracing::debug!("Error: postup command failed to execute {}", stderr);
./cableguard/src/device/mod.rs:                    let ipaddress = ipresponse.iter().next().expect("Error: No IP address found for subdomain");
./cableguard/src/device/mod.rs:                    cfgresponse.iter().next().expect("Error: No VPN Server Public Key found!");
./cableguard/src/device/mod.rs:                Err(_) => {tracing::debug!("Error: There is no RODT associated with the account");  }
./cableguard/src/device/mod.rs:                        TunnResult::Err(WireGuardError::ConnectionExpired) => {
./cableguard/src/device/mod.rs:                        TunnResult::Err(e) => tracing::debug!(message = "Error: Timer error", error = ?e),
./cableguard/src/device/mod.rs:                    let (own_bytes_private_key, own_bytes_public_key) = device.key_pair.as_ref().expect("Error: Key not set").clone();
./cableguard/src/device/mod.rs:                                                        .expect("Error: Self private key must be set before adding peers")
./cableguard/src/device/mod.rs:                                                        .expect("Error: Invalid private key bytes");
./cableguard/src/device/mod.rs:                                                    let allowed_ip: AllowedIP = allowed_ip_str.parse().expect("Error: Invalid Allowed IP");
./cableguard/src/device/mod.rs:                        Err(Error::IfaceRead(e)) => {
./cableguard/src/device/mod.rs:                            tracing::debug!("Error: Fatal read error on tun interface: {:?}", e);
./cableguard/src/device/mod.rs:                            tracing::debug!("Error: Unexpected error on tun interface: {:?}", e);
./cableguard/src/device/mod.rs:                            tracing::debug!(message = "Error: Encapsulate error", error = ?e)
./cableguard/src/device/mod.rs:                                tracing::debug!("Error: No endpoint");
./cableguard/src/device/mod.rs:        let allowed_ip: AllowedIP = allowed_ip_str.parse().expect("Error: Invalid own AllowedIP");
./cableguard/src/device/mod.rs:        // let ipv6_allowed_ip: AllowedIP = ipv6_allowed_ip_str.parse().expect("Error: Invalid IPv6 AllowedIP");
./cableguard/src/device/mod.rs:    // let ed25519_pub_bytes = hex::decode(key).expect("Error: Invalid hexadecimal string");
./cableguard/src/device/mod.rs:    let ed25519_pub_array: [u8; 32] = ed25519_pub_bytes.as_slice().try_into().expect("Error: Invalid length");
./.git/hooks/pre-commit.sample:Error: Attempt to add a non-ASCII file name.
./walletsh/cgtunup.sh:  echo "Error: Could not determine the WireGuard interface name."
./cableguard-cli/src/main.rs:            tracing::debug!("Error: Failed to open the file with the accountId: {}", err);
./cableguard-cli/src/main.rs:        tracing::debug!("Error: Failed to read the file with the accountId: {}", err);
./cableguard-cli/src/main.rs:            tracing::debug!("Error: Failed to parse JSON of the file with the accountId: {}", err);
./cableguard-cli/src/main.rs:    let account_id = json["account_id"].as_str().expect("Error: Invalid account_id value");
./cableguard-cli/src/main.rs:    let own_static_base58_private_ed25519_key = json["private_key"].as_str().expect("Error: Invalid private_key value");   
./cableguard-cli/src/main.rs:            tracing::debug!("Error: Account has no NEAR balance): {}", err);
./cableguard-cli/src/main.rs:            tracing::debug!("Error: There is no RODT associated with the account: {}", err);
./cableguard-cli/src/main.rs:        .expect("Error: Failed to decode the private key from Base58");
./cableguard-cli/src/main.rs:                Err(io::Error::new(
./cableguard-cli/src/main.rs:        .unwrap_or_else(|err| panic!("Error: Could not open log file {}: {}", log, err));
./cableguard-cli/src/main.rs:                    tracing::debug!("Error: CableGuard failed to start. Check if the capabilities are set and you are running with enough privileges.");
./cableguard-cli/src/main.rs:            tracing::debug!(message = "Error: Failed to initialize tunnel. Check if you are running with sudo", error=?e);
./cableguard-cli/src/main.rs:            tracing::debug!(message = "Error: Failed to drop privileges", error = ?e);
./cableguard-cli/src/main.rs:    let bytes = Vec::from_hex(&hex_string).expect("Error: Invalid Hex string");
